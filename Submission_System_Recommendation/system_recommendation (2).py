# -*- coding: utf-8 -*-
"""System_Recommendation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m8O2OpjITND9ASC9yuhFJpA4UEunM3-L

# **Proyek Machine Learning & Deep Learning - Music Recomendation**

# Data Understanding
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from scipy.sparse import hstack
from sklearn.metrics import mean_absolute_error

"""## Sumber Dataset

Dataset yang digunakan pada proyek ini berasal dari dataset pada Kaggle dengan nama [Spotify Tracks DB](https://www.kaggle.com/datasets/zaheenhamidani/ultimate-spotify-tracks-db) milik Zaheen Hamidani. Dataset ini berisi kumpulan informasi mengenai lagu-lagu populer yang dapat digunakan untuk membangun sistem rekomendasi musik.
Masing-masing entri dalam dataset mewakili satu lagu dengan beberapa fitur numerik dan kategorikal yang mendeskripsikan karakteristik lagu tersebut.
"""

file_id = "17Ooxn7vKOLIeITQQIK7cx0O_cBNLpoaG"
url = f"https://drive.google.com/uc?id={file_id}"

df = pd.read_csv(url)
df.head()

"""## Informasi Dataset"""

df.info()

"""**Insight**

Dataset `df` memiliki jumlah baris sebanyak 232.725 baris dengan 18 fitur
"""

df.duplicated().sum()

"""**Insight:**

Tidak terdapat data yang duplikat
"""

df.isnull().sum()

"""**Insight:**

Terdapat 1 missing value dari fitur `track_name`

## Menguraikan Seluruh Fitur Pada Dataset

**Berikut adalah penjelasan masing-masing fitur dalam dataset:**
- `genre`: Kategori genre lagu, berguna untuk segmentasi preferensi musik pengguna (tipe data kategori).
- `artist_name`: Nama artis/band yang membawakan lagu tersebut (tipe data kategori).
- `track_name`: Judul lagu (tipe data kategori).
- `track_id`: ID unik dari lagu, sebagai pengenal dalam sistem (tipe data kategori).
- `popularity`: Skor popularitas lagu berdasarkan jumlah pemutaran atau eksposur di platform digital (tipe data numerik).
- `acousticness`: Nilai lebih tinggi maka lagu lebih akustik (tipe data numerik).
- `danceability`: Menggambarkan seberapa cocok lagu untuk menari, berdasarkan tempo, irama, dan kestabilan beat (tipe data numerik).
- `duration_ms`: 	Durasi lagu dalam milidetik (tipe data numerik).
- `energy`: Lagu dengan nilai tinggi biasanya cepat dan keras (tipe data numerik).
- `instrumentalness`: Nilai mendekati 1 menunjukkan lagu sangat instrumental (tipe data numerik).
- `key`: Menunjukkan tangga nada dasar lagu (tipe data kategori).
- `liveness`: Mengindikasikan kemungkinan lagu direkam live (tipe data numerik).
- `loudness`: Tingkat kekerasan lagu (dalam dB). Bisa berpengaruh ke energi atau mood (tipe data numerik).
- `mode`: Mayor/minor (biasanya 1 = mayor, 0 = minor) (tipe data kategori).
- `speechiness`: Mengukur seberapa banyak elemen vokal/spoken. Mebedakan lagu instrumental vs lagu rap (tipe data numerik).
- `tempo`: Kecepatan lagu dalam BPM. Berpengaruh pada gaya musik dan mood (tipe data numerik).
- `time_signature`: Menunjukkan struktur ketukan lagu (umumnya 4/4) (tipe data kategori).
- `valence`: Mengukur kebahagiaan/mood lagu (0 = sedih, 1 = bahagia) (tipe data numerik).
"""

df.describe()

"""**Insight:**

1. Dataset ini terdiri dari 232725 data
2. Dataset ini terdiri dari 18 fitur
3. Terdapat 1 missing value
4. Tidak terdapat data yang duplikat
5. Rangkuman Statistik Deskriptif

### CountAndPlot

Untuk menghitung jumlah dan persentase kemunculan tiap kategori dalam sebuah fitur (kolom) DataFrame, menampilkannya dalam bentuk tabel, lalu memvisualisasikannya sebagai grafik batang. Dalam proyek ini akan difokuskan pada fitur `genre`
"""

def CountAndPlot(df, feature):
  count = df[feature].value_counts()
  percent = 100*df[feature].value_counts(normalize=True)
  samples = pd.DataFrame({'Sample Count':count, 'Percentage':percent.round(1)})
  print(samples)
  count.plot(kind='bar', title=feature)

CountAndPlot(df, 'genre')

"""**Insight:**

Terdapat genre musik Children's Music yang muncul dua kali dengan jumlah berbeda, perlu dilakukan analisis lebih lanjut

# Data Preprocessing

Pada tahap ini, dilakukan pembersihan data menangani missing values, mengatasi kedua nama genre yang mirip, dan memilih fitur yang relevan. Proses ini bertujuan untuk memastikan bahwa data yang digunakan bersih dan siap untuk dianalisis lebih lanjut.

## Mengatasi Missing Value

Dilakukan drop pada baris yang terdapat missing value
"""

df = df.dropna(subset=['track_name'])

df.isnull().sum()

"""**Insight:**

Tidak terdapat missing value, dapat dilanjutkan untuk analissi selanjutnya

## Menangani 2 Nama Genre Music yang mirip

Dilakukan analisis mengenai kedua genre music yakni Children’s Music dan Children's Music, apakah hanya terjadi duplikat atau merupakan genre yang berbeda

- Kedua nama fitur berbeda, `Children’s Music` menggunakan petik melengkung dan `Children's Music`menggunakan petik biasa

### Memeriksa isi dari kedua genre
"""

df[df['genre'].str.contains("Children", case=False, na=False)]['genre'].value_counts()

"""**Insight:**

Terlihat isi dari kedua genre berbeda, mengindikasikan bukan data duplikasi

### Memeriksa kesamaan isi data dari track_name dan track_id
"""

df_child1 = df[df['genre'] == "Children’s Music"]
df_child2 = df[df['genre'] == "Children's Music"]

same_tracks = pd.merge(df_child1, df_child2, on='track_name', how='inner')
print(same_tracks[['track_name', 'artist_name_x', 'artist_name_y']])

"""**Insight:**

Diperoleh bahwa kedua genre memiliki beberapa entri dengan judul lagu yang sama namun dinyanyikan oleh artis yang berbeda. Hal ini kemungkinan disebabkan oleh perbedaan versi lagu, seperti versi asli dan cover.

Oleh karena itu, akan dilakukan generalisasi atau standarisasi nama genre untuk menjaga konsistensi data. Namun, data tidak akan dihapus karena meskipun judul lagunya sama, karena kontennya berbeda, sehingga tetap relevan untuk dianalisis secara terpisah.

### Standarisasi Nama Genre
"""

df['genre'] = df['genre'].replace({'Children’s Music': "Children's Music"})

"""## Mengambil Subset Dataset Secara Acak

Karena ukuran dataset yang sangat besar membutuhkan waktu komputasi yang lama dan ruang penyimpanan yang besar, maka diputuskan untuk mengambil subset data sebanyak >= 10.000 baris.

Pemilihan subset dilakukan secara acak, kecuali untuk data dengan genre yang jarang muncul, seperti `"A Capella"`, yang akan dipertahankan seluruhnya agar tidak hilang dari analisis. Sementara itu, data dari genre lain akan diambil secara acak hingga total data mencapai batas 10.000 baris.
"""

genre_list = ['Children’s Music','Folk', 'Comedy', 'Jazz', 'Ska', 'Soundtrack', 'Alternative', 'Hip-Hop', 'Pop', 'World',
              'Indie', 'Anime', 'Rap', 'Electronic', 'Classical', 'Reggaeton', 'Rock', 'Reggae',
              'Country', 'Soul', 'Blues', 'Opera', 'R&B', 'Movie', 'Dance']

df_sampled = df[df['genre'].isin(genre_list)].sample(10000, random_state=42)

df_extra = df[df['genre'].isin(["A Capella"])]

df_new = pd.concat([df_sampled, df_extra], ignore_index=True)

def CountAndPlot(df, feature):
  count = df_new[feature].value_counts()
  percent = 100*df[feature].value_counts(normalize=True)
  samples = pd.DataFrame({'Sample Count':count, 'Percentage':percent.round(1)})
  print(samples)
  count.plot(kind='bar', title=feature)

CountAndPlot(df_new, 'genre')

"""**Insight:**

Diperoleh bahwa genre `"A Capella"` merupakan genre dengan data yang tersedikit, namun hal ini tetap akan dipertahankan untuk memberikan variasi pada genre

## Mengambil fitur yang relevan

Dataset memiliki total 18 fitur, namun tidak semuanya digunakan dalam proses pembuatan sistem rekomendasi. Pada proyek ini, sistem rekomendasi dikembangkan tidak hanya berdasarkan kemiripan 'Penyanyi' dan 'Judul Lagu', tetapi juga mempertimbangkan atribut-atribut audio dari setiap lagu.

Fitur-fitur yang dipilih mencakup:  
- `track_id`, `artist_name`, `track_name`, `genre`,  
- serta fitur audio seperti `acousticness`, `danceability`, `energy`, `instrumentalness`, `loudness`, `speechiness`, `tempo`, dan `valence`.

Pemilihan fitur ini bertujuan untuk menghasilkan rekomendasi lagu yang lebih relevan secara musikalitas dan karakteristik audio, bukan sekadar berdasarkan kemiripan teks atau artis.
"""

features = [
    'track_id','artist_name','track_name','genre','acousticness', 'danceability', 'energy', 'instrumentalness', 'loudness', 'speechiness', 'tempo', 'valence']

data = df_new[features]

audio_features = ['acousticness', 'danceability', 'energy', 'instrumentalness', 'loudness', 'speechiness', 'tempo', 'valence']

data.info()

data.describe()

"""**Insight:**

Dari hasil visualisasi dan eksplorasi data, ditemukan bahwa fitur `loudness` dan `tempo` memiliki skala dan distribusi nilai yang berbeda dibandingkan fitur lainnya. Perbedaan skala ini dapat menyebabkan bias dalam perhitungan kemiripan (cosine similarity), yakni fitur dengan skala besar akan memiliki pengaruh yang lebih besar.

Untuk mengatasi hal ini, diperlukan proses normalisasi atau standarisasi agar seluruh fitur berada dalam skala yang seragam. Dengan demikian, semua fitur dapat memberikan kontribusi yang seimbang dalam proses rekomendasi.

**Kesimpulan Akhir dari Proses Data Preprocessing**

Dataset telah dibersihkan dari missing value, nama genre yang mirip, dan telah mensortir fitur yang relevan digunakan dan telah disimpan dalam variabel `data`

# Data Preparation

Pada tahap selanjutnya dilakukan normalisasi nilai fitur audio dengan MinmAxScaler, membuat kombinasi nama, TF-IDF vektorizer dan penggabungan

## Normalisasi Fitur Audio

Dalam proyek ini digunakan metode **MinMaxScaler** untuk mengubah semua nilai fitur ke dalam rentang [0, 1], sehingga tidak ada fitur yang mendominasi perhitungan kemiripan.
"""

scaler = MinMaxScaler()
scaled_audio = scaler.fit_transform(data[audio_features])
data[audio_features] = scaler.fit_transform(data[audio_features])

data.describe()

"""**Insight:**

Dapat dilihat bahwa seluruh fitur memiliki skala dan distribusi nilai yang sama, sehingga bisa dilanjutkan ke tahap selanjutnya

## Membuat Kombinasi Nama

Hal ini dilakukan agar TF-IDF dapat menghitung kemiripan berdasarkan dua aspek yakni `artist_name` dan `genre`, dan menyimpannya dalam `'combined_text'`
"""

data['combined_text'] = data['artist_name'] + ' ' + data['genre']

"""## TF-IDF Vectorizer

Saat mencari sebuah lagu, agar sistem akan merekomendasikan lagu-lagu lain yang mirip baik dari segi penyanyi maupun karakteristik audio seperti `acousticness, danceability, energy, valence`, dan `tempo`, maka dilakukan penggabungan dari TF-IDF dan `scaled_audio`.
"""

tf = TfidfVectorizer()
tfidf_matrix = tf.fit_transform(data['combined_text'])

"""### Penggabungan"""

hybrid_matrix = hstack([tfidf_matrix, scaled_audio])

"""# Model Development Content Based Filtering

Content-Based Filtering sangat cocok untuk sistem rekomendasi berbasis konten yang tidak melibatkan perilaku pengguna secara langsung, serta mempermudah interpretasi hasil karena rekomendasi diberikan berdasarkan kemiripan konten antar lagu. Namun metode ini memiliki kelemahan, adapauun kelemahan utamanya adalah masalah _overspecialization_, di mana sistem hanya merekomendasikan item yang sangat mirip dengan yang sudah dikenal atau disukai sebelumnya, sehingga mengurangi keberagaman rekomendasi. Selain itu, metode ini tidak dapat menangkap preferensi kolektif dari pengguna lain karena tidak melibatkan data komunitas atau perilaku pengguna secara luas. Kekurangan lainnya adalah ketergantungan tinggi terhadap kualitas dan kelengkapan fitur konten.

## Cosine Similarity

Gunakan teknik cosine similarity untuk menemukan lagu-lagu yang mirip secara musikal dengan lagu yang dicari
"""

cosine_sim = cosine_similarity(hybrid_matrix)
cosine_sim

"""## Membuat Dictionary Berisi 10 Lagu Paling Mirip

Menyusun top 10 rekomendasi lagu yang paling mirip untuk setiap lagu berdasarkan skor cosine similarity
"""

top_k_sim = {}

for i in range(cosine_sim.shape[0]):
    top_indices = np.argsort(cosine_sim[i])[::-1][:10]
    key = data['track_name'].iloc[i] + '-' + data['artist_name'].iloc[i]
    similar_items = data.iloc[top_indices][['track_name', 'artist_name']].apply(
        lambda x: f"{x['track_name']} - {x['artist_name']}", axis=1).tolist()
    top_k_sim[key] = similar_items

"""## Mendapatkan Rekomendasi

Memberikan rekomendasi lagu yang mirip dengan lagu input, berdasarkan kemiripan fitur (hasil dari cosine_similarity), dengan referensi pada `track_name` dan `artist_name`.
"""

def music_recommendations(track_name_input, artist_input, similarity_data=top_k_sim, k=5):
    """
    Rekomendasikan lagu mirip berdasarkan track dan artist
    """
    key = f"{track_name_input}-{artist_input}"

    if key not in similarity_data:
        print("Lagu tidak ditemukan di data.")
        return pd.DataFrame()

    recommended_keys = similarity_data[key][:k]

    recommended_data = []
    for item in recommended_keys:
        parts = item.rsplit(" - ", 1)
        if len(parts) == 2:
            recommended_data.append(parts)
        else:
            print(f"Warning: Skipping item '{item}' as it could not be parsed into track and artist.")
            continue

    if not recommended_data:
        print("No valid recommendations found after parsing.")
        return pd.DataFrame()

    recommended_df = pd.DataFrame(recommended_data, columns=["track_name", "artist_name"])

    return pd.merge(recommended_df, data, on=["track_name", "artist_name"], how="left")[[
         'track_id','artist_name','track_name','genre','acousticness', 'danceability', 'energy', 'instrumentalness', 'loudness', 'speechiness', 'tempo', 'valence'
    ]]

music_recommendations("How to Be Married", "Jackie Kashian")

"""## Evaluation

### Visual Similarity Inspection

Membandingkan nilai fitur audio (seperti acousticness, danceability, dll) antara lagu input dan lagu hasil rekomendasi.

Visualisasi ini memudahkan untuk melihat seberapa mirip pola fitur kedua lagu dalam bentuk garis.

**Cara Kerja Visual Similarity Inspection**

- Ekstraksi Fitur Audio:

  Ambil nilai dari fitur-fitur audio
  
- Plotting Nilai Fitur:
   - Visualisasi berupa plot garis (line plot), sumbu-X merepresentasikan nama fitur audio, dan sumbu-Y adalah nilai normalisasi dari masing-masing fitur. Lagu input digambarkan dengan satu garis, dan setiap lagu rekomendasi digambarkan dengan garis lain

- Perbandingan Visual:

  Semakin mirip bentuk kurva/grafiknya, semakin mirip juga karakteristik musikal dari lagu-lagu tersebut.
"""

input_track = data[(data['track_name'] == 'How to Be Married') & (data['artist_name'] == 'Jackie Kashian')][audio_features].iloc[0]
rekomendasi = music_recommendations("How to Be Married", "Jackie Kashian")

for idx, row in rekomendasi.iterrows():
    plt.figure(figsize=(6,3))
    plt.plot(audio_features, input_track.values, label='Input Song')
    plt.plot(audio_features, row[audio_features].values, label=row['track_name'], linestyle='--')
    plt.legend()
    plt.title(f"Comparing with: {row['track_name']}")
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

"""**Salah satu interpretasi dari grafik diatas:**

Rekomendasi "Life Is Short" cukup mirip dengan lagu How to Be Married karena memiliki kesamaan pada aspek instrumental, keras suara, dan unsur bicara, meskipun sedikit berbeda dalam tempo dan suasana emosional (valence).

### Mean Absolute Error (MAE) antar fitur

Untuk mengukur kinerja sistem rekomendasi lagu berbasis konten, digunakan metrik Mean Absolute Error (MAE). Metrik ini mengukur seberapa besar rata-rata perbedaan absolut antara fitur-fitur lagu input dan lagu yang direkomendasikan.

**Rumus MAE:**

$$
\text{MAE} = \frac{1}{n} \sum_{i=1}^{n} | y_i - \hat{y}_i |
$$

**Keterangan:**
- yᵢ: nilai fitur lagu asli
- ŷᵢ: nilai fitur lagu hasil rekomendasi
- n: jumlah fitur audio yang dibandingkan

**Dengan cara kerja:**

- Untuk setiap lagu rekomendasi, dibandingkan nilai fitur audionya dengan lagu input.

- Seluruh selisih absolut dihitung untuk fitur seperti acousticness, danceability, energy, valence, dan tempo.

- MAE yang lebih kecil menunjukkan bahwa fitur-fitur lagu tersebut memiliki kriteria yang sangat mirip dengan lagu input.
"""

if not rekomendasi.empty:
    for index, row in rekomendasi.iterrows():
        recommended_song_features = row[audio_features]

        mae = mean_absolute_error(input_track.values, recommended_song_features.values)

        print(f"Mean Absolute Error (MAE) untuk '{row['track_name']}' - '{row['artist_name']}': {mae:.4f}")
else:
    print("Tidak ada rekomendasi")

"""**Insight:**

- Diperoleh nilai MAE dari kemiripan lagu 'How to Be Married' dengan 'How to Be Married' adalah 0, yang artinya sama persis karena memang membandingkan dengan lagu yang sama
- Diperoleh nilai MAE dari kemiripan lagu 'How to Be Married' dengan 'Bite Suit' adalah 0.0385, menunjukkan bahwa rekomendasi lagu 'Bite Suit' **sangat mirip** dengan lagu "How to Be Married".
- Diperoleh nilai MAE dari kemiripan lagu 'How to Be Married' dengan 'Episode 6 "Smokes, Jokes And Froze-Tokes"' - 'T.J. Miller' adalah 0.0739, menunjukkan bahwa rekomendasi lagu 'Episode 6 "Smokes, Jokes And Froze-Tokes"' - 'T.J. Miller' **cukup mirip** dengan lagu "How to Be Married".
- Diperoleh nilai MAE dari kemiripan lagu 'How to Be Married' dengan 'Toots and Farts' adalah 0.0604, menunjukkan bahwa rekomendasi lagu 'Toots and Farts' **cukup mirip** dengan lagu "How to Be Married".
- Diperoleh nilai MAE dari kemiripan lagu 'How to Be Married' dengan 'Life Is Short' - 'Sinbad' adalah 0.0737, menunjukkan bahwa rekomendasi lagu 'Life Is Short' - 'Sinbad' **cukup mirip** dengan lagu "How to Be Married".

Diantara kedua bentuk evaluasi, metode evaluasi dengan MAE menunjukkan hasil yang dapat dipercaya dibandingkan hanya dengan melihat visualisasinya.
"""